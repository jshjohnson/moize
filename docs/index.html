<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>moize Index</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.paper.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">moize</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-8">
	
		<div id="main">
			

	
	



    <h3>moize 5.4.2</h3>









	
	





    <section class="readme-section">
        <article><h1 id="moize">moize</h1>
<img src="https://img.shields.io/badge/build-passing-brightgreen.svg"/>
<img src="https://img.shields.io/badge/coverage-100%25-brightgreen.svg"/>
<img src="https://img.shields.io/badge/license-MIT-blue.svg"/>
<p><code>moize</code> is a <a href="#benchmarks">consistently blazing fast</a> memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers a large number of options to satisfy any number of potential use-cases.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#moize">moize</a>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#importing">Importing</a></li>
<li><a href="#usage">Usage</a>
<ul>
<li><a href="#types">Types</a></li>
</ul>
</li>
<li><a href="#configuration-options">Configuration options</a>
<ul>
<li><a href="#equals">equals</a></li>
<li><a href="#isdeepequal">isDeepEqual</a></li>
<li><a href="#ispromise">isPromise</a></li>
<li><a href="#isreact">isReact</a></li>
<li><a href="#isserialized">isSerialized</a></li>
<li><a href="#matcheskey">matchesKey</a></li>
<li><a href="#maxage">maxAge</a></li>
<li><a href="#maxargs">maxArgs</a></li>
<li><a href="#maxsize">maxSize</a></li>
<li><a href="#oncacheadd">onCacheAdd</a></li>
<li><a href="#oncachechange">onCacheChange</a></li>
<li><a href="#oncachehit">onCacheHit</a></li>
<li><a href="#onexpire">onExpire</a></li>
<li><a href="#profilename">profileName</a></li>
<li><a href="#serializer">serializer</a></li>
<li><a href="#transformargs">transformArgs</a></li>
<li><a href="#updateexpire">updateExpire</a></li>
<li><a href="#useprofilenameinlocation">useProfileNameInLocation</a></li>
</ul>
</li>
<li><a href="#global-configuration">Global configuration</a>
<ul>
<li><a href="#moizecollectstats">moize.collectStats</a></li>
<li><a href="#moizesetdefaultoptions">moize.setDefaultOptions</a></li>
</ul>
</li>
<li><a href="#usage-with-shortcut-methods">Usage with shortcut methods</a>
<ul>
<li><a href="#moizedeep">moize.deep</a></li>
<li><a href="#moizeinfinite">moize.infinite</a></li>
<li><a href="#moizemaxage">moize.maxAge</a></li>
<li><a href="#moizemaxargs">moize.maxArgs</a></li>
<li><a href="#moizemaxsize">moize.maxSize</a></li>
<li><a href="#moizepromise">moize.promise</a></li>
<li><a href="#moizereact">moize.react</a></li>
<li><a href="#moizereactglobal">moize.reactGlobal</a></li>
<li><a href="#moizeserialize">moize.serialize</a></li>
</ul>
</li>
<li><a href="#composition">Composition</a></li>
<li><a href="#collecting-statistics">Collecting statistics</a></li>
<li><a href="#introspection">Introspection</a>
<ul>
<li><a href="#getstats">getStats</a></li>
<li><a href="#iscollectingstats">isCollectingStats</a></li>
<li><a href="#ismoized">isMoized</a></li>
</ul>
</li>
<li><a href="#direct-cache-manipulation">Direct cache manipulation</a>
<ul>
<li><a href="#cache">cache</a></li>
<li><a href="#cachesnapshot">cache.snapshot</a></li>
<li><a href="#clear">clear</a></li>
<li><a href="#delete">delete</a></li>
<li><a href="#get">get</a></li>
<li><a href="#getstats-1">getStats</a></li>
<li><a href="#has">has</a></li>
<li><a href="#keys">keys</a></li>
<li><a href="#set">set</a></li>
<li><a href="#values">values</a></li>
</ul>
</li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#filesize">Filesize</a></li>
<li><a href="#browser-support">Browser support</a></li>
<li><a href="#development">Development</a></li>
</ul>
</li>
</ul>
<h2 id="installation">Installation</h2>
<pre class="prettyprint source"><code>$ npm i moize --save
</code></pre>
<h2 id="importing">Importing</h2>
<p>ESM syntax in browsers:</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';
</code></pre>
<p>ESM syntax in NodeJS:</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize/mjs';
</code></pre>
<p>CommonJS:</p>
<pre class="prettyprint source lang-ts"><code>const moize = require('moize');
</code></pre>
<h2 id="usage">Usage</h2>
<pre class="prettyprint source lang-ts"><code>const method = (a: number, b: number) => {
  return a + b;
};

const memoized = moize(method);

memoized(2, 4); // 6
memoized(2, 4); // 6, pulled from cache
</code></pre>
<p>All parameter types are supported, including circular objects, functions, etc. There are also a number of <a href="#usage-with-shortcut-methods">shortcut methods</a> to memoize for unique use-cases.</p>
<h4 id="types">Types</h4>
<p>Since version <code>6.0.0</code>, the library is now written in TypeScript, and has such has full typing. Types are available under the <code>Moize</code> namespace.</p>
<h2 id="configuration-options">Configuration options</h2>
<p><code>moize</code> optionally accepts an object of options as either the second parameter or as the first step in a curried function:</p>
<pre class="prettyprint source lang-ts"><code>// inline
moize(fn, options);

// curried
moize(options)(fn);
</code></pre>
<p>The full shape of these options:</p>
<pre class="prettyprint source lang-typescript"><code>type Options = {
  [key: string]: any;
  [index: number]: any;

  // custom equality comparator comparing a specific key argument
  equals?: (cacheKeyArgument: any, keyArgument: any) => boolean;

  // is key comparison done via deep equality
  isDeepEqual?: boolean;

  // is the result a promise
  isPromise?: boolean;

  // is the method a functional React component
  isReact?: boolean;

  // should the react component be memoized across all instances
  isReactGlobal?: boolean;

  // should the parameters be serialized instead of directly referenced
  isSerialized?: boolean;

  // custom equality comparator comparing the entire key
  matchesKey?: (cacheKey: any[], key: any[]) => boolean;

  // amount of time in milliseconds before the cache will expire
  maxAge?: number;

  // maximum number of arguments to use as key for caching
  maxArgs?: number;

  // maximum size of cache for this method
  maxSize?: number;

  // a callback when a new cache item is added
  onCacheAdd?: (cache: Cache, options: Options, moized: Function) => void;

  // a callback when the cache changes
  onCacheChange?: (cache: Cache, options: Options, moized: Function) => void;

  // a callback when an existing cache item is retrieved
  onCacheHit?: (cache: Cache, options: Options, moized: Function) => void;

  // a callback when a cache item expires
  onExpire?: (key: any) => boolean | void;

  // a custom name to associate stats for the method to
  profileName?: string;

  // provide a serializer and override default,
  serializer?: (args: any[]) => any[];

  // transform the args prior to storage as key
  transformArgs?: (args: any[]) => any[];

  // should the expiration be updated when cache is hit
  updateExpire?: boolean;

  // should the file location be included in the profile name (EXPENSIVE)
  useProfileNameLocation?: boolean;
};
</code></pre>
<h4 id="equals">equals</h4>
<p><em>defaults to <a href="http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero">SameValueZero</a> equality</em></p>
<p>Custom method used to compare equality of keys for cache purposes by comparing each argument.</p>
<pre class="prettyprint source lang-ts"><code>// using lodash's deep equal comparison method
const fn = ({ foo, bar }: { foo: string, bar: string }) => [foo, bar];

const memoized = moize(fn, {
  equals(
    cacheKeyArgument: { foo: string, bar?: string}, 
    keyArgument: { foo: string, bar?: string }
  ) {
    return cacheKeyArgument.foo === 'bar' && keyArgument.foo === 'bar';
  },
});

memoized({ foo: 'bar' });
memoized({ foo: 'bar', bar: 'baz' }); // pulls from cache
</code></pre>
<p>The <code>equals</code> method receives two parameters (cache key arguments) and should return a <code>boolean</code>.</p>
<p><strong>NOTE</strong>: This comparison is used iteratively on each argument, rather than comparing the two keys as a whole. If you want to compare the key as a whole, you should use <a href="#matcheskey"><code>matchesKey</code></a>.</p>
<h4 id="isdeepequal">isDeepEqual</h4>
<p><em>defaults to false</em></p>
<p>Should deep equality be used to compare cache keys. This is also available via the shortcut method of <a href="#moizedeep"><code>moize.deep</code></a></p>
<pre class="prettyprint source lang-ts"><code>const fn = ({ foo, bar }: { foo: string, bar: string }) => [foo, bar];

const memoized = moize(fn, { isDeepEqual: true });

memoized({ foo: 'foo', bar: 'bar' });
memoized({ foo: 'foo', bar: 'bar' }); // pulls from cache
</code></pre>
<h4 id="ispromise">isPromise</h4>
<p><em>defaults to false</em></p>
<p>Is the computed value in the function a <code>Promise</code>. This is also available via the shortcut method of <a href="#moizepromise"><code>moize.promise</code></a>.</p>
<pre class="prettyprint source lang-ts"><code>const fn = async (item: Promise&lt;any>) => await item;

const memoized = moize(fn, { isPromise: true });
</code></pre>
<p>The <code>Promise</code> itself will be stored in cache, so that cached returns will always maintain the <code>Promise</code> contract. For common usage reasons, if the <code>Promise</code> is rejected, the cache entry will be deleted.</p>
<h4 id="isreact">isReact</h4>
<p><em>defaults to false</em></p>
<p>Is the function passed a stateless functional <code>React</code> component. This is also available via the shortcut method of <a href="#moizereact"><code>moize.react</code></a>.</p>
<pre class="prettyprint source lang-ts"><code>const Foo = ({ bar, baz }: { bar: any, baz: any }) => {
  return (
    &lt;div>
      {bar}: {baz}
    &lt;/div>
  );
};

export default moize(Foo, { isReact: true });
</code></pre>
<p>The method will do a shallow equal comparison of both <code>props</code> and <code>context</code> of the component based on strict equality. If you want to do a deep equals comparison, set <a href="#isdeepequal"><code>isDeepEqual</code></a> to true.</p>
<h4 id="isserialized">isSerialized</h4>
<p><em>defaults to false</em></p>
<p>Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of <a href="#moizeserialize"><code>moize.serialize</code></a>.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (mutableObject: { foo: any }) => mutableObject.foo;

const memoized = moize(fn, { isSerialized: true });

const object = { foo: 'foo' };

memoized(object); // 'foo'

object.foo = 'bar';

memoized(object); // 'bar'
</code></pre>
<p>If <code>serialize</code> is combined with either <code>maxArgs</code> or <code>transformArgs</code>, the following order is used:</p>
<ol>
<li>limit by <code>maxArgs</code> (if applicable)</li>
<li>transform by <code>transformArgs</code> (if applicable)</li>
<li>serialize by <code>serializer</code></li>
</ol>
<p><strong>NOTE</strong>: This is much slower than the default key storage, and usually the same requirements can be meet with <code>isDeepEqual</code>, so use at your discretion.</p>
<h4 id="matcheskey">matchesKey</h4>
<p>Custom method used to compare equality of keys for cache purposes by comparing the entire key.</p>
<pre class="prettyprint source lang-ts"><code>// using lodash's deep equal comparison method
const fn = ({ foo, bar }: { foo: string, bar: string | void }) => [foo, bar];

const memoized = moize(fn, {
  matchesKey(cacheKey: Moize.Key, key: Moize.Key) {
    return (
      cacheKey[0].foo === key[0].foo &&
      cacheKey[1].hasOwnProperty('bar') &&
      key[1].hasOwnProperty('bar')
    );
  },
});

memoized({ foo: 'bar' }, { bar: null });
memoized({ foo: 'bar' }, { bar: 'baz' }); // pulls from cache
</code></pre>
<p>The <code>matchesKey</code> method receives two parameters (cache keys) and should return a <code>boolean</code>.</p>
<p><strong>NOTE</strong>: This comparison uses the two keys as a whole, which is usually less performant than the <code>equals</code> comparison used iteratively on each argument. Generally speaking you should use the <a href="#equals"><code>equals</code></a> option for equality comparison.</p>
<h4 id="maxage">maxAge</h4>
<p>The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of <a href="#moizemaxage"><code>moize.maxAge</code></a>.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (item: any) => item;

const memoized = moize(fn, {
  maxAge: 1000 * 60 * 5, // five minutes
});
</code></pre>
<h4 id="maxargs">maxArgs</h4>
<p>The maximum number of arguments (starting from the first) used in creating the key for the cache. This is also available via the shortcut method of <a href="#moizemaxargs"><code>moize.maxArgs</code></a>.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (item1: string, item2: string, item3: string) => `${item1} ${item2} ${item3}`;

const memoized = moize(fn, { maxArgs: 2 });

memoize('foo', 'bar', 'baz');
memoize('foo', 'bar', 'quz'); // pulls from cache, as the first two args are the same
</code></pre>
<p>If <code>maxArgs</code> is combined with either <code>serialize</code> or <code>transformArgs</code>, the following order is used:</p>
<ol>
<li>limit by <code>maxArgs</code></li>
<li>transform by <code>transformArgs</code> (if applicable)</li>
<li>serialize by <code>serializer</code> (if applicable)</li>
</ol>
<h4 id="maxsize">maxSize</h4>
<p><em>defaults to Infinity</em></p>
<p>The maximum number of values you want stored in cache for this method. Clearance of the cache once the <code>maxSize</code> is reached is on a <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29">Least Recently Used</a> basis. This is also available via the shortcut method of <a href="#moizemaxsize"><code>moize.maxSize</code></a>.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (item: any) => item;

const memoized = moize(fn, { maxSize: 5 });
</code></pre>
<h4 id="oncacheadd">onCacheAdd</h4>
<p>Method to fire when an item has been added to cache. Receives the cache, options, and memoized function as a parameters.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (foo: string, bar: string) => [foo, bar];

const moized = moize(fn, {
  onCacheAdd(
    cache: Moize.Cache, 
    options: Moize.Options, 
    moized: Moize.Moized&lt;typeof fn>
  ) {
    console.log(cache.keys);
  },
});

moized('foo', 'bar'); // [[&quot;foo&quot;,&quot;bar&quot;]]
moized('foo', 'bar');
moized('bar', 'foo'); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]
moized('foo', 'bar');
</code></pre>
<p><strong>NOTE</strong>: When combined with <code>onCacheChange</code>, this method will always fire first.</p>
<h4 id="oncachechange">onCacheChange</h4>
<p>Method to fire when an item has been either added to cache, or existing cache was reordered based on a cache hit. Receives the cache, options, and memoized function as a parameters.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (foo, bar) => [foo, bar];

const moized = moize(fn, {
  onCacheChange(
    cache: Moize.Cache, 
    options: Moize.Options, 
    moized: Moize.Moized&lt;typeof fn>
  ) {
    console.log(cache.keys);
  },
});

moized('foo', 'bar'); // [[&quot;foo&quot;,&quot;bar&quot;]]
moized('foo', 'bar');
moized('bar', 'foo'); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]
moized('foo', 'bar'); // [[&quot;foo&quot;,&quot;bar&quot;], [&quot;bar&quot;,&quot;foo&quot;]]
</code></pre>
<p><strong>NOTE</strong>: When combined with <code>onCacheAdd</code> or <code>onCacheHit</code>, this method will always fire last.</p>
<h4 id="oncachehit">onCacheHit</h4>
<p>Method to fire when an existing cache item is found. Receives the cache, options, and memoized function as a parameters.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (foo, bar) => [foo, bar];

const moized = moize(fn, {
  onCacheHit(
    cache: Moize.Cache, 
    options: Moize.Options, 
    moized: Moize.Moized&lt;typeof fn>
  ) {
    console.log(cache.keys);
  },
});

moized('foo', 'bar');
moized('foo', 'bar'); // [[&quot;foo&quot;,&quot;bar&quot;]]
moized('bar', 'foo');
moized('foo', 'bar'); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]
</code></pre>
<p><strong>NOTE</strong>: When combined with <code>onCacheChange</code>, this method will always fire first.</p>
<h4 id="onexpire">onExpire</h4>
<p>A callback that is called when the cached entry expires.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (item: any) => item;

const memoized = moize(fn, {
  maxAge: 10000,
  onExpire(key: Moize.Key) {
    console.log(key);
  },
});
</code></pre>
<p>This method receives the <code>key</code> being expired, while corresponds to the list of arguments passed to <code>moize</code> for the cached value.</p>
<p>If you return <code>false</code> from this method, it will prevent the <code>key</code>'s removal and refresh the expiration in the same vein as <code>updateExpire</code> based on <code>maxAge</code>:</p>
<pre class="prettyprint source lang-ts"><code>const fn = (item: any) => item;

let expirationAttempts = 0;

const memoized = moize(fn, {
  maxAge: 1000 * 10, // 10 seconds
  onExpire(key: Moize.Key) {
    expirationAttempts++;

    return expirationAttempts &lt; 2;
  },
});

memoized('foo'); // will expire key after 30 seconds, or 3 expiration attempts
</code></pre>
<p><strong>NOTE</strong>: You must set a <a href="#maxage"><code>maxAge</code></a> for this option to take effect.</p>
<h4 id="profilename">profileName</h4>
<p><em>defaults to function name with counter</em></p>
<p>Name to use as unique identifier for the function when collecting statistics.</p>
<pre class="prettyprint source lang-ts"><code>moize.collectStats();

const fn = (item: any) => item;

const memoized = moize(fn, { profileName: 'my fancy identity' });
</code></pre>
<p><strong>NOTE</strong>: You must be collecting statistics for this option to take effect.</p>
<p><strong>TIP</strong>: For better debugging, you can set <a href="#useprofilenameinlocation"><code>useProfileNameInLocation</code></a> to <code>true</code> and the file and line number of the call will be included in the name. This is optional because it is an expensive operation.</p>
<h4 id="serializer">serializer</h4>
<p><em>defaults to argumentSerializer in serialize.ts</em></p>
<p>Method used in place of the internal serializer when serializing the parameters for cache key comparison. The function accepts a single argument, the <code>Array</code> of <code>args</code>, and must also return an <code>Array</code>.</p>
<pre class="prettyprint source lang-ts"><code>const serializer = (args: any[]): [string] => [JSON.stringify(args[0])];

const memoized = moize(fn, { isSerialized: true, serializer });
</code></pre>
<p><strong>NOTE</strong>: You must set <a href="#isserialized"><code>isSerialized</code></a> for this option to take effect.</p>
<h4 id="transformargs">transformArgs</h4>
<p>Transform the arguments passed before it is used as a key. The function accepts a single argument, the <code>Array</code> of <code>args</code>, and must also return an <code>Array</code>.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (one: any, two: any, three: any) => [two, three];

const moized = moize(fn, {
  transformArgs(args: any[]) {
    return args.slice(1);
  },
});

moize('foo', 'bar', 'baz');
moize(null, 'bar', 'baz'); // pulled from cache
</code></pre>
<p>If <code>transformArgs</code> is combined with either <code>maxArgs</code> or <code>serialize</code>, the following order is used:</p>
<ol>
<li>limit by <code>maxArgs</code> (if applicable)</li>
<li>transform by <code>transformArgs</code></li>
<li>serialize by <code>serializer</code> (if applicable)</li>
</ol>
<h4 id="updateexpire">updateExpire</h4>
<p>When a <code>maxAge</code> is set, clear the scheduled expiration of the key when that key is retrieved, setting a new expiration based on the most recent retrieval from cache.</p>
<p>This defaults to <code>true</code> due to common use cases.</p>
<pre class="prettyprint source lang-ts"><code>const fn = (item: any) => any;

const FIVE_MINUTES = 1000 * 60 * 5;
const memoized = moize(fn, { maxAge: FIVE_MINUTES });

memoized('foo');

setTimeout(() => {
  memoized('foo');
  // hits cache, which updates the expire to be 5 minutes from this call
}, 1000 * 60);
</code></pre>
<h4 id="useprofilenameinlocation">useProfileNameInLocation</h4>
<p>When determining the <code>profileName</code> for the function, include the file / line in the profile name. This helps with debugging.</p>
<pre class="prettyprint source lang-ts"><code>moize.collectStats();

const fn = (item: any) => item;

const memoized = moize(fn, { 
  profileName: 'my fancy identity', 
  useProfileNameInLocation: true 
});
</code></pre>
<p><strong>NOTE</strong>: You must be collecting statistics for this option to take effect.</p>
<h2 id="global-configuration">Global configuration</h2>
<h4 id="moize.collectstats">moize.collectStats</h4>
<p>Start collecting stats on memoization usage.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

moize.collectStats();
</code></pre>
<p>For more information about using statistics, <a href="#statistics">read the documentation here</a>.</p>
<p><strong>NOTE</strong>: It is recommended not to activate this with the <code>useProfileNameInLocation</code> option set to <code>true</code> in production, as it can have a signifcant performance cost.</p>
<h4 id="moize.setdefaultoptions">moize.setDefaultOptions</h4>
<p>Sometimes there are defaults you want for <code>moize</code> to use throughout your application that do not align with the built-in default options. Starting in version 6, you can set the default options used globally.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

moize.setDefaultOptions({ maxSize: 5 });
</code></pre>
<p>After this setting, all calls to <code>moize</code> will use a <code>maxSize</code> of <code>5</code>. Whatever options you provide are merged into the existing defaults, so this can be updated at runtime as you wish.</p>
<p><strong>NOTE</strong>: If you want to provide context-specific settings for your application, it is recommended to create a custom implementation and use that instead of the global <code>moize</code>:</p>
<pre class="prettyprint source lang-ts"><code>const deepEqualReactMoize = moize.react({ isDeepEqual: true });
</code></pre>
<h2 id="usage-with-shortcut-methods">Usage with shortcut methods</h2>
<h4 id="moize.deep">moize.deep</h4>
<p>Pre-applies the <code>isDeepEqual</code> option to <code>true</code>.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = (bar: string, baz: string) => `${bar} ${baz}`;

export default moize.deep(foo);
</code></pre>
<h4 id="moize.infinite">moize.infinite</h4>
<p>Pre-applies the <code>maxSize</code> option with <code>Infinity</code>.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = (bar: string, baz: string) => `${bar} ${baz}`;

export default moize.infinite(foo);
</code></pre>
<h4 id="moize.maxage">moize.maxAge</h4>
<p>Pre-applies the <code>maxAge</code> option as a curriable method.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = (bar: string, baz: string) => `${bar} ${baz}`;

export default moize.maxAge(5000)(foo);
</code></pre>
<h4 id="moize.maxargs">moize.maxArgs</h4>
<p>Pre-applies the <code>maxArgs</code> option as a curriable method.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = (bar: string, baz: string) => `${bar} ${baz}`;

export default moize.maxArgs(1)(foo);
</code></pre>
<h4 id="moize.maxsize">moize.maxSize</h4>
<p>Pre-applies the <code>maxSize</code> option as a curriable method.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = (bar: string, baz: string) => `${bar} ${baz}`;

export default moize.maxSize(5)(foo);
</code></pre>
<h4 id="moize.promise">moize.promise</h4>
<p>Pre-applies the <code>isPromise</code> and <code>updateExpire</code> options to <code>true</code>.</p>
<p>The <code>updateExpire</code> option does nothing if <code>maxAge</code> is not also applied, but ensures that the expiration begins at the resolution of the promise rather than the instantiation of it.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = async (bar: string, baz: string) => await someApiCall(bar, baz);

export default moize.promise(foo);
</code></pre>
<p><strong>NOTE</strong>: If you do not want the promise to update its expiration when the cache is hit, then you should use the <code>isPromise</code> option directly instead.</p>
<h4 id="moize.react">moize.react</h4>
<p>Pre-applies the <code>isReact</code> option to <code>true</code>.</p>
<p>Shortcut for memoizing functional components in <a href="https://github.com/facebook/react">React</a> on a per-instance basis. Key comparisons are based on a shallow equal comparison of both props and context.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

type Props = { bar: string, baz: string };

const Foo = ({ bar, baz }: Props) => {
  return (
    &lt;div>
      {bar} {baz}
    &lt;/div>
  );
};

export default moize.react(Foo);
</code></pre>
<p><strong>NOTE</strong>: This method will not operate with components made via the <code>class</code> instantiation, as they do not offer the same <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>.</p>
<h4 id="moize.reactglobal">moize.reactGlobal</h4>
<p>Pre-applies the <code>isReact</code> option to <code>true</code>, and <code>isReactGlobal</code> option to <code>true</code>.</p>
<p>Shortcut for memoizing functional components in <a href="https://github.com/facebook/react">React</a> across all instances.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

type Props = { bar: string, baz: string };

const Foo = ({ bar, baz }: Props) => {
  return (
    &lt;div>
      {bar} {baz}
    &lt;/div>
  );
};

export default moize.reactGlobal(Foo);
</code></pre>
<p><strong>NOTE</strong>: This method will not operate with components made via the <code>class</code> instantiation, as they do not offer the same <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>.</p>
<h4 id="moize.serialize">moize.serialize</h4>
<p>Pre-applies the <code>isSerialized</code> option to <code>true</code>.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

const foo = (bar: string, baz: string) => `${bar} ${baz}`;

export default moize.serialize(foo);
</code></pre>
<h2 id="composition">Composition</h2>
<p>Starting with version <code>2.3.0</code>, you can compose <code>moize</code> methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example:</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

type Props = { someProp: string };

const Foo = (props: Props) => &lt;div {...props} />;

// memoizing with react, as since 2.0.0
const MemoizedFoo = moize.react(Foo);

// creating a separately-memoized method that has maxSize of 5
const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);
</code></pre>
<p>You can also create an options-first curriable version of <code>moize</code> if you only pass the options:</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

// creates a function that will memoize what is passed
const limitedSerializedMoize = moize({ isSerialized: true, maxSize: 5 });

const foo = bird => {
  return `${bird} is the word`;
};

const moizedFoo = limitedSerializedMoize(foo);
</code></pre>
<p>You can also combine all of these options with <code>moize.compose</code> to create <code>moize</code> wrappers with pre-defined options.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

// creates a moizer that will have the options of
// {isReact: true, maxAge: 5000, maxSize: 5}
const superLimitedReactMoize = moize.compose(
  moize.react,
  moize.maxSize(5),
  moize.maxAge(5000),
);
</code></pre>
<h2 id="collecting-statistics">Collecting statistics</h2>
<p>As-of version <code>5.0.0</code>, you can collect statistics of moize to determine if your cached methods are effective.</p>
<pre class="prettyprint source lang-ts"><code>import moize from 'moize';

moize.collectStats();

const fn = (foo, bar) => [foo, bar];

const moized = moize(fn);

moized('foo', 'bar');
moized('foo', 'bar');

moized.getStats(); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}
</code></pre>
<p><strong>NOTE</strong>: It is recommended not to activate this in production, as it will have a performance decrease.</p>
<h2 id="introspection">Introspection</h2>
<h4 id="getstats">getStats</h4>
<p>Get the statistics for a specific function, or globally.</p>
<pre class="prettyprint source lang-ts"><code>collectStats();

const fn = (foo, bar) => [foo, bar];

const moized = moize(fn);

const otherFn = bar => bar.slice(0, 1);

const otherMoized = moize(otherFn, { profileName: 'otherMoized' });

moized('foo', 'bar');
moized('foo', 'bar');

moized.getStats(); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}

otherMoized(['baz']);

moize.getStats('otherMoized'); // {&quot;calls&quot;: 1, &quot;hits&quot;: 0, &quot;usage&quot;: &quot;0%&quot;}

moize.getStats();
/*
 {
   &quot;calls&quot;: 3,
   &quot;hits&quot;: 1,
   &quot;profiles&quot;: {
     &quot;fn at Object..src/utils.js (http://localhost:3000/app.js:153:68)&quot;: {
       &quot;calls&quot;: 2,
       &quot;hits&quot;: 1,
       &quot;usage&quot;: &quot;50%&quot;
     },
     &quot;otherMoized&quot;: {
       &quot;calls&quot;: 1,
       &quot;hits&quot;: 0,
       &quot;usage&quot;: &quot;0%&quot;
     }
   },
   &quot;usage&quot;: &quot;33.3333%&quot;
 }
 */
</code></pre>
<h4 id="iscollectingstats">isCollectingStats</h4>
<p>Are statistics being collected on memoization usage.</p>
<pre class="prettyprint source lang-ts"><code>moize.isCollectingStats(); // false

collectStats();

moize.isCollectingStats(); // true
</code></pre>
<h4 id="ismoized">isMoized</h4>
<p>Is the function passed a moized function.</p>
<pre class="prettyprint source lang-ts"><code>const fn = () => {};

const moizedFn = moize(fn);

moize.isMoized(fn); // false
moize.isMoized(moizedFn); // true
</code></pre>
<h2 id="direct-cache-manipulation">Direct cache manipulation</h2>
<p>The cache is available on the <code>moize</code>d function as a property, and while it is not recommended to modify it directly, that option is available for edge cases.</p>
<h4 id="cache">cache</h4>
<p>The shape of the <code>cache</code> is as follows:</p>
<pre class="prettyprint source lang-typescript"><code>type Cache = {
  keys: (any[])[]; // also available as Moize.Key[]
  size: number;
  values: any[]; // also available as Moize.Value[]
};
</code></pre>
<p>Regardless of how the key is transformed, it is always stored as an array (if the value returned is not an array, it is coalesced to one).</p>
<p><strong>NOTE</strong>: The order of <code>keys</code> and <code>values</code> should always align, so be aware when manually manipulating the cache that you need to manually keep in sync any changes to those arrays.</p>
<h4 id="cache.snapshot">cache.snapshot</h4>
<p>The <code>cache</code> is mutated internally for performance reasons, so logging out the cache at a specific step in the workflow may not give you the information you need. As such, to help with debugging you can request the <code>cacheSnapshot</code>, which has the same shape as the <code>cache</code> but is a shallow clone of each property for persistence.</p>
<p>There are also convenience methods provided on the <code>moize</code>d function which allow for programmatic manipulation of the cache.</p>
<h4 id="clear">clear</h4>
<p><code>() =&gt; boolean</code></p>
<p>This will clear all values in the cache, resetting it to an empty state.</p>
<pre class="prettyprint source lang-ts"><code>const memoized = moize((item: any) => item);

const didClear = memoized.clear();
</code></pre>
<p>This returns <code>true</code> if cache cleared successfully.</p>
<h4 id="delete">delete</h4>
<p><code>(key: Moize.Key) =&gt; boolean</code></p>
<p>This will remove the provided <em>key</em> from cache. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-ts"><code>const memoized = moize((item: any) => any);

const foo = { bar: 'baz' };

memoized(foo);

const didRemove = memoized.delete([foo]);

// will re-execute, as it is no longer in cache
memoized(foo);
</code></pre>
<h4 id="get">get</h4>
<p><code>(key: Moize.Key) =&gt; Moize.Value | void</code></p>
<p>Returns the value in cache if the key matches, else returns <code>undefined</code>. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-ts"><code>const memoized = moize((first: string, second: string) => [first, second]);

memoized('foo', 'bar');

console.log(memoized.get(['foo', 'bar'])); // [&quot;foo&quot;,&quot;bar&quot;]
console.log(memoized.get(['bar', 'baz'])); // undefined
</code></pre>
<h4 id="getstats-2">getStats</h4>
<p><code>() =&gt; Moize.StatsObject</code></p>
<p>Returns the statistics for the function.</p>
<pre class="prettyprint source lang-ts"><code>collectStats();

const memoized = moize((first: string, second: string) => [first, second]);

memoized('foo', 'bar');
memoized('foo', 'bar');

console.log(memoized.getStats()); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}
</code></pre>
<p><strong>NOTE</strong>: You must be collecting statistics for this to be populated.</p>
<h4 id="has">has</h4>
<p><code>(key: Moize.Key) =&gt; boolean</code></p>
<p>This will return <code>true</code> if a cache entry exists for the <em>key</em> passed, else will return <code>false</code>. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-ts"><code>const memoized = moize((first: string, second: string) => [first, second]);

memoized('foo', 'bar');

console.log(memoized.has(['foo', 'bar'])); // true
console.log(memoized.has(['bar', 'baz'])); // false
</code></pre>
<h4 id="keys">keys</h4>
<p><code>() =&gt; Moized.Key[]</code></p>
<p>This will return a list of the current keys in <code>cache</code>.</p>
<pre class="prettyprint source lang-ts"><code>const memoized = moize((item: any) => any);

const foo = 'foo';

memoized(foo);

const bar = { baz: 'baz' };

memoized(bar);

const keys = memoized.keys(); // [['foo'], [{baz: 'baz'}]]
</code></pre>
<p>The value returned is <code>true</code> if an entry was deleted, <code>false</code> if not.</p>
<p><strong>NOTE</strong>: This will only remove <code>key</code>s that exist in the cache, and will do nothing if the <code>key</code> does not exist.</p>
<h4 id="set">set</h4>
<p><code>(key: Moize.Key, value: Moize.Value) =&gt; boolean</code></p>
<p>This will manually add the <em>value</em> at <em>key</em> in cache if <em>key</em> does not already exist, or update the <em>value</em> at <em>key</em> if it does. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-ts"><code>// single parameter is straightforward
const memoized = moize((item: string) => item);

// adds the key => value, as it is not in cache
memoized.set(['foo'], 'bar');

// pulls from cache
memoized('foo');

// updates the key => value, as it already is in cache
memoized.set(['foo'], 'baz');
</code></pre>
<p>The value returned is <code>true</code> if an entry was added / updated, <code>false</code> if not.</p>
<h4 id="values">values</h4>
<p><code>() =&gt; Moize.Value[]</code></p>
<p>This will return a list of the current values in <code>cache</code>.</p>
<pre class="prettyprint source lang-ts"><code>const memoized = moize((item: any) => ({ item }));

const foo = 'foo';

memoized(foo);

const bar = { baz: 'baz' };

memoized(bar);

const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]
</code></pre>
<h2 id="benchmarks">Benchmarks</h2>
<p>All values provided are the number of operations per second calculated by <a href="https://www.npmjs.com/package/benchee">benchee</a>, where a higher value is better. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of <code>35</code>, using single and multiple parameters with different object types. The results were averaged to determine overall speed across possible usage.</p>
<p><strong>NOTE</strong>: <code>lodash</code>, <code>ramda</code>, and <code>underscore</code> do not support mulitple-parameter memoization without use of a <code>resolver</code> function. For consistency in comparison, each use the same <code>resolver</code> that returns the result of <code>JSON.stringify</code> on the arguments.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Overall (average)</th>
<th>single primitive</th>
<th>single array</th>
<th>single object</th>
<th>multiple primitive</th>
<th>multiple array</th>
<th>multiple object</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>moize</strong></td>
<td><strong>28,592,886</strong></td>
<td><strong>37,390,978</strong></td>
<td><strong>28,443,977</strong></td>
<td><strong>28,377,652</strong></td>
<td><strong>24,972,215</strong></td>
<td><strong>25,001,120</strong></td>
<td><strong>24,998,368</strong></td>
</tr>
<tr>
<td>lru-memoize</td>
<td>21,491,988</td>
<td>39,937,384</td>
<td>20,342,667</td>
<td>20,924,765</td>
<td>17,346,234</td>
<td>16,322,914</td>
<td>17,300,359</td>
</tr>
<tr>
<td>lodash</td>
<td>12,104,503</td>
<td>25,416,048</td>
<td>23,301,328</td>
<td>27,505,049</td>
<td>1,389,241</td>
<td>1,087,838</td>
<td>877,620</td>
</tr>
<tr>
<td>memoizee</td>
<td>9,515,597</td>
<td>15,799,929</td>
<td>10,643,471</td>
<td>10,740,599</td>
<td>6,572,612</td>
<td>7,013,962</td>
<td>6,818,388</td>
</tr>
<tr>
<td>fast-memoize</td>
<td>7,463,418</td>
<td>51,566,160</td>
<td>1,615,649</td>
<td>1,426,880</td>
<td>1,268,116</td>
<td>979,444</td>
<td>819,221</td>
</tr>
<tr>
<td>memoizerific</td>
<td>5,117,778</td>
<td>5,641,768</td>
<td>5,539,880</td>
<td>5,533,768</td>
<td>4,496,953</td>
<td>4,711,212</td>
<td>4,705,524</td>
</tr>
<tr>
<td>underscore</td>
<td>4,230,089</td>
<td>20,965,582</td>
<td>2,108,270</td>
<td>1,828,023</td>
<td>1,459,836</td>
<td>1,126,566</td>
<td>910,574</td>
</tr>
<tr>
<td>mem</td>
<td>4,089,526</td>
<td>19,888,317</td>
<td>2,093,008</td>
<td>1,786,244</td>
<td>2,345,978</td>
<td>1,661,802</td>
<td>1,054,462</td>
</tr>
<tr>
<td>ramda</td>
<td>4,070,948</td>
<td>21,712,404</td>
<td>2,335,372</td>
<td>2,066,631</td>
<td>1,498,134</td>
<td>1,153,950</td>
<td>916,465</td>
</tr>
<tr>
<td>addy-osmani</td>
<td>2,200,040</td>
<td>5,824,585</td>
<td>1,586,101</td>
<td>1,448,906</td>
<td>3,081,196</td>
<td>975,378</td>
<td>775,256</td>
</tr>
</tbody>
</table>
<h2 id="filesize">Filesize</h2>
<p><code>moize</code> is fairly small (about 3.2KB when minified and gzipped), however it provides a large number of configuration options to satisfy a number of edge cases. If filesize is a concern, you may consider using <a href="https://github.com/planttheidea/micro-memoize"><code>micro-memoize</code></a>. This is the memoization library that powers <code>moize</code> under-the-hood, and will handle most common use cases at 1/2 the size of <code>moize</code>.</p>
<h2 id="browser-support">Browser support</h2>
<ul>
<li>Chrome (all versions)</li>
<li>Firefox (all versions)</li>
<li>Edge (all versions)</li>
<li>Opera 15+</li>
<li>IE 9+</li>
<li>Safari 6+</li>
<li>iOS 8+</li>
<li>Android 4+</li>
</ul>
<h2 id="development">Development</h2>
<p>Standard stuff, clone the repo and <code>npm install</code> dependencies. The npm scripts available:</p>
<ul>
<li><code>benchmark</code> =&gt; run the benchmark suite pitting <code>moize</code> against other libraries in common use-cases</li>
<li><code>benchmark:alternative</code> =&gt; run the benchmark suite for alternative forms of caching in <code>moize</code></li>
<li><code>build</code> =&gt; run rollup to build the distributed files in <code>dist</code></li>
<li><code>clean</code> =&gt; run <code>clean:lib</code>, <code>clean:es</code>, <code>clean:dist</code>, and <code>clean:docs</code></li>
<li><code>clean:dist</code> =&gt; run <code>rimraf</code> on the <code>dist</code> folder</li>
<li><code>clean:docs</code> =&gt; run <code>rimraf</code> on the <code>docs</code> folder</li>
<li><code>clean:es</code> =&gt; run <code>rimraf</code> on the <code>es</code> folder</li>
<li><code>clean:lib</code> =&gt; run <code>rimraf</code> on the <code>lib</code> folder</li>
<li><code>dev</code> =&gt; run webpack dev server to run example app (playground!)</li>
<li><code>dist</code> =&gt; runs <code>clean:dist</code> and <code>build</code></li>
<li><code>docs</code> =&gt; runs <code>clean:docs</code> and builds the docs via <code>jsdoc</code></li>
<li><code>flow</code> =&gt; runs <code>flow check</code> on the files in <code>src</code></li>
<li><code>lint</code> =&gt; runs ESLint against all files in the <code>src</code> folder</li>
<li><code>lint:fix</code> =&gt; runs `lint``, fixing any errors if possible</li>
<li><code>postpublish</code> =&gt; runs <code>docs</code></li>
<li><code>prepublish</code> =&gt; runs <code>compile-for-publish</code></li>
<li><code>prepublish:compile</code> =&gt; run <code>lint</code>, <code>flow</code>, <code>test:coverage</code>, <code>transpile:lib</code>, <code>transpile:es</code>, and <code>dist</code></li>
<li><code>test</code> =&gt; run AVA test functions with <code>NODE_ENV=test</code></li>
<li><code>test:coverage</code> =&gt; run <code>test</code> but with <code>nyc</code> for coverage checker</li>
<li><code>test:watch</code> =&gt; run <code>test</code>, but with persistent watcher</li>
<li><code>transpile:es</code> =&gt; run babel against all files in <code>src</code> to create files in <code>es</code>, preserving ES2015 modules (for <a href="https://github.com/rollup/rollup/wiki/pkg.module"><code>pkg.module</code></a>)</li>
<li><code>transpile:lib</code> =&gt; run babel against all files in <code>src</code> to create files in <code>lib</code></li>
</ul></article>
    </section>







		</div>
	</div>

	<div class="clearfix"></div>

	
		<div class="col-md-3">
			<div id="toc" class="col-md-3 hidden-xs hidden-sm hidden-md"></div>
		</div>
	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->

<script>
	$( function () {
		$( '#main' ).localScroll( {
			offset : { top : 60 } //offset by the height of your header (give or take a few px, see what works for you)
		} );
		$( "dt.name" ).each( function () {
			var $this = $( this ).find("h4");
			var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" ).addClass( "icon-white" );
			var dt = $(this);
			var children = dt.next( "dd" );

			dt.prepend( icon ).css( {cursor : "pointer"} );
			dt.addClass( "member-collapsed" ).addClass( "member" );


			children.hide();

			dt.children().on( "click", function () {
				children = dt.next( "dd" );
				children.slideToggle( "fast", function () {

					if ( children.is( ":visible" ) ) {
						icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" ).removeClass( "icon-white" );
						dt.addClass( "member-open" ).animate( "member-collapsed" );
					} else {
						icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" ).addClass( "icon-white" );
						dt.addClass( "member-collapsed" ).removeClass( "member-open" );
					}
				} );
			} );

		} );
	} );
</script>


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>