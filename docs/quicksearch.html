<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"moized.ts.html":{"id":"moized.ts.html","title":"Source: moized.ts","body":" moize Global loadReact Source: moized.ts /* globals define */ import memoize, { MicroMemoize } from 'micro-memoize'; import { enhanceCache } from './cache'; import { clearExpiration } from './maxAge'; import { getStats } from './stats'; import { assign } from './utils'; import { Moize } from './types'; /* eslint-disable react/forbid-foreign-prop-types */ const GLOBAL = (() =&gt; { if (typeof globalThis !== 'undefined') { // eslint-disable-next-line no-undef return globalThis; } if (typeof window !== 'undefined') { // eslint-disable-next-line no-undef return window; } if (typeof global !== 'undefined') { return global; } })(); const REACT_OPTIONS = { isReact: true, isReactGlobal: true }; const EMPTY_OBJECT = {}; const ReactNoopUpdater = { enqueueForceUpdate() {}, enqueueReplaceState() {}, enqueueSetState() {}, isMounted() { return false; }, }; export const STATIC_VALUES = ['cache']; export const STATIC_METHODS = [ 'clear', 'delete', 'get', 'getStats', 'has', 'keys', 'set', 'values', ]; function defineStaticProperty&lt;Fn extends Moize.Moizable&gt;( fn: Moize.Moized&lt;Fn&gt;, propertyName: keyof Moize.Moized&lt;Fn&gt;, isMethod: boolean, ) { const message = `${propertyName} is not available on MoizedComponent directly. You can access it on the instance by capturing the ref and accessing the \"Moized\" property on it.`; if (isMethod) { fn[propertyName] = function () { throw new Error(message); }; } else { Object.defineProperty(fn, propertyName, { get() { throw new Error(message); }, }); } } let React: { createElement: Function } = GLOBAL &amp;&amp; 'React' in GLOBAL &amp;&amp; GLOBAL.React; /** * @function loadReact * * @description * `react` is a special dependency; unlike the others in this project, we should not * import it unless we actually need it. * * If `React` is not available globally, then attempt the various loading mechanisms: * * - Synchronous `require` (CommonJS) * - Asynchronous `define` (AMD) * - Asynchronous `import` (ESM) * * This mimics the rollup logic, including order of operations, with the addition of the * dynamic `import()` syntax in case this is being run in a browser `&lt;script type=\"module\"&gt;`. * * Throw an error if not able to successfully use any technique. */ function loadReact() { function onLoad(pkg: any) { React = pkg; } function onFail() { throw new Error( 'You have tried to use the `isReact` option when React is not installed. Please install install `react` as a dependency of your project.', ); } try { if (typeof exports === 'object' &amp;&amp; typeof module !== 'undefined') { // eslint-disable-next-line global-require,import/no-extraneous-dependencies React = require('react'); // @ts-ignore } else if (typeof define === 'function' &amp;&amp; define.amd) { // @ts-ignore define(['react'], onLoad); } else { import('react') .catch(onFail) .then(onLoad); } } catch { onFail(); } } export function createMoizedComponent&lt;Fn extends Moize.Moizable&gt;( moize: Moize.Moizer&lt;Fn&gt;, fn: Fn, options?: Moize.Options, ) { const componentOptions = options ? assign({}, options, REACT_OPTIONS) : REACT_OPTIONS; type ComponentClass = import('react').ComponentClass&lt;GenericProps, any&gt;; type FunctionComponent = import('react').FunctionComponent; type GenericProps = import('react').Props&lt;any&gt;; type Component = import('react').Component&lt;GenericProps, any, any&gt;; type MoizedComponent = ComponentClass &amp; Moize.Moized&lt;Fn&gt;; if (!React) { loadReact(); } /** * @NOTE This is basically creating a custom React.Component class * * Not only is this faster, it is also less code for the compiler to produce. */ /* eslint-disable react/no-this-in-sfc */ // @ts-ignore const MoizedComponent: MoizedComponent = function MoizedComponent( props: GenericProps, context: Moize.Dictionary&lt;any&gt;, updater: any, ): Component { this.props = props; this.context = context; this.refs = EMPTY_OBJECT; this.updater = updater || ReactNoopUpdater; this.Moized = moize(fn, componentOptions); return this; }; MoizedComponent.prototype.isReactComponent = EMPTY_OBJECT; MoizedComponent.prototype.render = function () { return React.createElement( (this.Moized as unknown) as FunctionComponent, this.props, ); }; MoizedComponent.options = options; MoizedComponent.fn = fn; Object.keys(fn).forEach((staticKey) =&gt; { // @ts-ignore MoizedComponent[staticKey] = fn[staticKey]; }); MoizedComponent.displayName = getDisplayName(fn); STATIC_METHODS.forEach((method) =&gt; { defineStaticProperty(MoizedComponent, method, true); }); STATIC_VALUES.forEach((value) =&gt; { defineStaticProperty(MoizedComponent, value, false); }); /* eslint-enable */ // eslint-disable-next-line global-require,import/no-extraneous-dependencies return MoizedComponent; } export function createMoized&lt;Fn extends Moize.Moizable&gt;( moize: Moize.Moizer&lt;Fn&gt;, fn: Fn, options: Moize.Options, ) { if (options.isReact &amp;&amp; !options.isReactGlobal) { return createMoizedComponent(moize, fn, options); } const { _mm: microMemoizeOptions } = options; const moized = memoize(fn, microMemoizeOptions) as Moize.Moized&lt;Fn&gt;; moized.options = options; Object.keys(fn).forEach((staticKey) =&gt; { // @ts-ignore moized[staticKey] = fn[staticKey]; }); if (options.isReact) { moized.displayName = getDisplayName(fn); } const { cache } = moized; /* eslint-disable func-names */ moized.clear = function () { cache.keys.length = 0; cache.values.length = 0; if (cache.shouldUpdateOnChange) { microMemoizeOptions.onCacheChange(cache, options, moized); } return true; }; moized.delete = function (key: MicroMemoize.Key) { if (cache.canTransformKey) { key = microMemoizeOptions.transformKey(key); } const keyIndex = cache.getKeyIndex(key); if (~keyIndex) { const existingKey = cache.keys[keyIndex]; cache.keys.splice(keyIndex, 1); cache.values.splice(keyIndex, 1); if (cache.shouldUpdateOnChange) { microMemoizeOptions.onCacheChange(cache, options, moized); } clearExpiration(cache, existingKey, true); return true; } return false; }; moized.get = function (key: MicroMemoize.Key) { if (cache.canTransformKey) { key = microMemoizeOptions.transformKey(key); } const keyIndex = cache.getKeyIndex(key); if (~keyIndex) { return cache.values[keyIndex]; } }; moized.getStats = function () { return getStats(options.profileName); }; moized.has = function (key: MicroMemoize.Key) { if (cache.canTransformKey) { key = microMemoizeOptions.transformKey(key); } return !!~cache.getKeyIndex(key); }; moized.keys = function () { return cache.snapshot.keys; }; moized.set = function (key: MicroMemoize.Key, value: MicroMemoize.Value) { if (cache.canTransformKey) { key = microMemoizeOptions.transformKey(key); } const index = cache.getKeyIndex(key); const isAdd = index === -1; cache.orderByLru(key, value, isAdd ? cache.size : index); if (isAdd &amp;&amp; cache.shouldUpdateOnAdd) { microMemoizeOptions.onCacheAdd(cache, options, moized); } if (cache.shouldUpdateOnChange) { microMemoizeOptions.onCacheChange(cache, options, moized); } return true; }; moized.values = function () { return cache.snapshot.values; }; /* eslint-enable */ enhanceCache(cache); return moized; } function getDisplayName(fn: Moize.Moizable) { return `Moized(${fn.displayName || fn.name || 'Component'})`; } Ã— Search results Close Documentation generated by JSDoc 3.6.2 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" moize Global loadReact Global Methods loadReact() `react` is a special dependency; unlike the others in this project, we should not import it unless we actually need it. If `React` is not available globally, then attempt the various loading mechanisms: - Synchronous `require` (CommonJS) - Asynchronous `define` (AMD) - Asynchronous `import` (ESM) This mimics the rollup logic, including order of operations, with the addition of the dynamic `import()` syntax in case this is being run in a browser ` "},"index.html":{"id":"index.html","title":"Index","body":" moize Global loadReact moize 5.4.2 moize moize is a consistently blazing fast memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers a large number of options to satisfy any number of potential use-cases. Table of contents moize Table of contents Installation Importing Usage Types Configuration options equals isDeepEqual isPromise isReact isSerialized matchesKey maxAge maxArgs maxSize onCacheAdd onCacheChange onCacheHit onExpire profileName serializer transformArgs updateExpire useProfileNameInLocation Global configuration moize.collectStats moize.setDefaultOptions Usage with shortcut methods moize.deep moize.infinite moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactGlobal moize.serialize Composition Collecting statistics Introspection getStats isCollectingStats isMoized Direct cache manipulation cache cache.snapshot clear delete get getStats has keys set values Benchmarks Filesize Browser support Development Installation $ npm i moize --save Importing ESM syntax in browsers: import moize from 'moize'; ESM syntax in NodeJS: import moize from 'moize/mjs'; CommonJS: const moize = require('moize'); Usage const method = (a: number, b: number) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cache All parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to memoize for unique use-cases. Types Since version 6.0.0, the library is now written in TypeScript, and has such has full typing. Types are available under the Moize namespace. Configuration options moize optionally accepts an object of options as either the second parameter or as the first step in a curried function: // inline moize(fn, options); // curried moize(options)(fn); The full shape of these options: type Options = { [key: string]: any; [index: number]: any; // custom equality comparator comparing a specific key argument equals?: (cacheKeyArgument: any, keyArgument: any) =&gt; boolean; // is key comparison done via deep equality isDeepEqual?: boolean; // is the result a promise isPromise?: boolean; // is the method a functional React component isReact?: boolean; // should the react component be memoized across all instances isReactGlobal?: boolean; // should the parameters be serialized instead of directly referenced isSerialized?: boolean; // custom equality comparator comparing the entire key matchesKey?: (cacheKey: any[], key: any[]) =&gt; boolean; // amount of time in milliseconds before the cache will expire maxAge?: number; // maximum number of arguments to use as key for caching maxArgs?: number; // maximum size of cache for this method maxSize?: number; // a callback when a new cache item is added onCacheAdd?: (cache: Cache, options: Options, moized: Function) =&gt; void; // a callback when the cache changes onCacheChange?: (cache: Cache, options: Options, moized: Function) =&gt; void; // a callback when an existing cache item is retrieved onCacheHit?: (cache: Cache, options: Options, moized: Function) =&gt; void; // a callback when a cache item expires onExpire?: (key: any) =&gt; boolean | void; // a custom name to associate stats for the method to profileName?: string; // provide a serializer and override default, serializer?: (args: any[]) =&gt; any[]; // transform the args prior to storage as key transformArgs?: (args: any[]) =&gt; any[]; // should the expiration be updated when cache is hit updateExpire?: boolean; // should the file location be included in the profile name (EXPENSIVE) useProfileNameLocation?: boolean; }; equals defaults to SameValueZero equality Custom method used to compare equality of keys for cache purposes by comparing each argument. // using lodash's deep equal comparison method const fn = ({ foo, bar }: { foo: string, bar: string }) =&gt; [foo, bar]; const memoized = moize(fn, { equals( cacheKeyArgument: { foo: string, bar?: string}, keyArgument: { foo: string, bar?: string } ) { return cacheKeyArgument.foo === 'bar' &amp;&amp; keyArgument.foo === 'bar'; }, }); memoized({ foo: 'bar' }); memoized({ foo: 'bar', bar: 'baz' }); // pulls from cache The equals method receives two parameters (cache key arguments) and should return a boolean. NOTE: This comparison is used iteratively on each argument, rather than comparing the two keys as a whole. If you want to compare the key as a whole, you should use matchesKey. isDeepEqual defaults to false Should deep equality be used to compare cache keys. This is also available via the shortcut method of moize.deep const fn = ({ foo, bar }: { foo: string, bar: string }) =&gt; [foo, bar]; const memoized = moize(fn, { isDeepEqual: true }); memoized({ foo: 'foo', bar: 'bar' }); memoized({ foo: 'foo', bar: 'bar' }); // pulls from cache isPromise defaults to false Is the computed value in the function a Promise. This is also available via the shortcut method of moize.promise. const fn = async (item: Promise&lt;any&gt;) =&gt; await item; const memoized = moize(fn, { isPromise: true }); The Promise itself will be stored in cache, so that cached returns will always maintain the Promise contract. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({ bar, baz }: { bar: any, baz: any }) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true }); The method will do a shallow equal comparison of both props and context of the component based on strict equality. If you want to do a deep equals comparison, set isDeepEqual to true. isSerialized defaults to false Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of moize.serialize. const fn = (mutableObject: { foo: any }) =&gt; mutableObject.foo; const memoized = moize(fn, { isSerialized: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar' If serialize is combined with either maxArgs or transformArgs, the following order is used: limit by maxArgs (if applicable) transform by transformArgs (if applicable) serialize by serializer NOTE: This is much slower than the default key storage, and usually the same requirements can be meet with isDeepEqual, so use at your discretion. matchesKey Custom method used to compare equality of keys for cache purposes by comparing the entire key. // using lodash's deep equal comparison method const fn = ({ foo, bar }: { foo: string, bar: string | void }) =&gt; [foo, bar]; const memoized = moize(fn, { matchesKey(cacheKey: Moize.Key, key: Moize.Key) { return ( cacheKey[0].foo === key[0].foo &amp;&amp; cacheKey[1].hasOwnProperty('bar') &amp;&amp; key[1].hasOwnProperty('bar') ); }, }); memoized({ foo: 'bar' }, { bar: null }); memoized({ foo: 'bar' }, { bar: 'baz' }); // pulls from cache The matchesKey method receives two parameters (cache keys) and should return a boolean. NOTE: This comparison uses the two keys as a whole, which is usually less performant than the equals comparison used iteratively on each argument. Generally speaking you should use the equals option for equality comparison. maxAge The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = (item: any) =&gt; item; const memoized = moize(fn, { maxAge: 1000 * 60 * 5, // five minutes }); maxArgs The maximum number of arguments (starting from the first) used in creating the key for the cache. This is also available via the shortcut method of moize.maxArgs. const fn = (item1: string, item2: string, item3: string) =&gt; `${item1} ${item2} ${item3}`; const memoized = moize(fn, { maxArgs: 2 }); memoize('foo', 'bar', 'baz'); memoize('foo', 'bar', 'quz'); // pulls from cache, as the first two args are the same If maxArgs is combined with either serialize or transformArgs, the following order is used: limit by maxArgs transform by transformArgs (if applicable) serialize by serializer (if applicable) maxSize defaults to Infinity The maximum number of values you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = (item: any) =&gt; item; const memoized = moize(fn, { maxSize: 5 }); onCacheAdd Method to fire when an item has been added to cache. Receives the cache, options, and memoized function as a parameters. const fn = (foo: string, bar: string) =&gt; [foo, bar]; const moized = moize(fn, { onCacheAdd( cache: Moize.Cache, options: Moize.Options, moized: Moize.Moized&lt;typeof fn&gt; ) { console.log(cache.keys); }, }); moized('foo', 'bar'); // [[\"foo\",\"bar\"]] moized('foo', 'bar'); moized('bar', 'foo'); // [[\"bar\",\"foo\"], [\"foo\",\"bar\"]] moized('foo', 'bar'); NOTE: When combined with onCacheChange, this method will always fire first. onCacheChange Method to fire when an item has been either added to cache, or existing cache was reordered based on a cache hit. Receives the cache, options, and memoized function as a parameters. const fn = (foo, bar) =&gt; [foo, bar]; const moized = moize(fn, { onCacheChange( cache: Moize.Cache, options: Moize.Options, moized: Moize.Moized&lt;typeof fn&gt; ) { console.log(cache.keys); }, }); moized('foo', 'bar'); // [[\"foo\",\"bar\"]] moized('foo', 'bar'); moized('bar', 'foo'); // [[\"bar\",\"foo\"], [\"foo\",\"bar\"]] moized('foo', 'bar'); // [[\"foo\",\"bar\"], [\"bar\",\"foo\"]] NOTE: When combined with onCacheAdd or onCacheHit, this method will always fire last. onCacheHit Method to fire when an existing cache item is found. Receives the cache, options, and memoized function as a parameters. const fn = (foo, bar) =&gt; [foo, bar]; const moized = moize(fn, { onCacheHit( cache: Moize.Cache, options: Moize.Options, moized: Moize.Moized&lt;typeof fn&gt; ) { console.log(cache.keys); }, }); moized('foo', 'bar'); moized('foo', 'bar'); // [[\"foo\",\"bar\"]] moized('bar', 'foo'); moized('foo', 'bar'); // [[\"bar\",\"foo\"], [\"foo\",\"bar\"]] NOTE: When combined with onCacheChange, this method will always fire first. onExpire A callback that is called when the cached entry expires. const fn = (item: any) =&gt; item; const memoized = moize(fn, { maxAge: 10000, onExpire(key: Moize.Key) { console.log(key); }, }); This method receives the key being expired, while corresponds to the list of arguments passed to moize for the cached value. If you return false from this method, it will prevent the key's removal and refresh the expiration in the same vein as updateExpire based on maxAge: const fn = (item: any) =&gt; item; let expirationAttempts = 0; const memoized = moize(fn, { maxAge: 1000 * 10, // 10 seconds onExpire(key: Moize.Key) { expirationAttempts++; return expirationAttempts &lt; 2; }, }); memoized('foo'); // will expire key after 30 seconds, or 3 expiration attempts NOTE: You must set a maxAge for this option to take effect. profileName defaults to function name with counter Name to use as unique identifier for the function when collecting statistics. moize.collectStats(); const fn = (item: any) =&gt; item; const memoized = moize(fn, { profileName: 'my fancy identity' }); NOTE: You must be collecting statistics for this option to take effect. TIP: For better debugging, you can set useProfileNameInLocation to true and the file and line number of the call will be included in the name. This is optional because it is an expensive operation. serializer defaults to argumentSerializer in serialize.ts Method used in place of the internal serializer when serializing the parameters for cache key comparison. The function accepts a single argument, the Array of args, and must also return an Array. const serializer = (args: any[]): [string] =&gt; [JSON.stringify(args[0])]; const memoized = moize(fn, { isSerialized: true, serializer }); NOTE: You must set isSerialized for this option to take effect. transformArgs Transform the arguments passed before it is used as a key. The function accepts a single argument, the Array of args, and must also return an Array. const fn = (one: any, two: any, three: any) =&gt; [two, three]; const moized = moize(fn, { transformArgs(args: any[]) { return args.slice(1); }, }); moize('foo', 'bar', 'baz'); moize(null, 'bar', 'baz'); // pulled from cache If transformArgs is combined with either maxArgs or serialize, the following order is used: limit by maxArgs (if applicable) transform by transformArgs serialize by serializer (if applicable) updateExpire When a maxAge is set, clear the scheduled expiration of the key when that key is retrieved, setting a new expiration based on the most recent retrieval from cache. This defaults to true due to common use cases. const fn = (item: any) =&gt; any; const FIVE_MINUTES = 1000 * 60 * 5; const memoized = moize(fn, { maxAge: FIVE_MINUTES }); memoized('foo'); setTimeout(() =&gt; { memoized('foo'); // hits cache, which updates the expire to be 5 minutes from this call }, 1000 * 60); useProfileNameInLocation When determining the profileName for the function, include the file / line in the profile name. This helps with debugging. moize.collectStats(); const fn = (item: any) =&gt; item; const memoized = moize(fn, { profileName: 'my fancy identity', useProfileNameInLocation: true }); NOTE: You must be collecting statistics for this option to take effect. Global configuration moize.collectStats Start collecting stats on memoization usage. import moize from 'moize'; moize.collectStats(); For more information about using statistics, read the documentation here. NOTE: It is recommended not to activate this with the useProfileNameInLocation option set to true in production, as it can have a signifcant performance cost. moize.setDefaultOptions Sometimes there are defaults you want for moize to use throughout your application that do not align with the built-in default options. Starting in version 6, you can set the default options used globally. import moize from 'moize'; moize.setDefaultOptions({ maxSize: 5 }); After this setting, all calls to moize will use a maxSize of 5. Whatever options you provide are merged into the existing defaults, so this can be updated at runtime as you wish. NOTE: If you want to provide context-specific settings for your application, it is recommended to create a custom implementation and use that instead of the global moize: const deepEqualReactMoize = moize.react({ isDeepEqual: true }); Usage with shortcut methods moize.deep Pre-applies the isDeepEqual option to true. import moize from 'moize'; const foo = (bar: string, baz: string) =&gt; `${bar} ${baz}`; export default moize.deep(foo); moize.infinite Pre-applies the maxSize option with Infinity. import moize from 'moize'; const foo = (bar: string, baz: string) =&gt; `${bar} ${baz}`; export default moize.infinite(foo); moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from 'moize'; const foo = (bar: string, baz: string) =&gt; `${bar} ${baz}`; export default moize.maxAge(5000)(foo); moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from 'moize'; const foo = (bar: string, baz: string) =&gt; `${bar} ${baz}`; export default moize.maxArgs(1)(foo); moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from 'moize'; const foo = (bar: string, baz: string) =&gt; `${bar} ${baz}`; export default moize.maxSize(5)(foo); moize.promise Pre-applies the isPromise and updateExpire options to true. The updateExpire option does nothing if maxAge is not also applied, but ensures that the expiration begins at the resolution of the promise rather than the instantiation of it. import moize from 'moize'; const foo = async (bar: string, baz: string) =&gt; await someApiCall(bar, baz); export default moize.promise(foo); NOTE: If you do not want the promise to update its expiration when the cache is hit, then you should use the isPromise option directly instead. moize.react Pre-applies the isReact option to true. Shortcut for memoizing functional components in React on a per-instance basis. Key comparisons are based on a shallow equal comparison of both props and context. import moize from 'moize'; type Props = { bar: string, baz: string }; const Foo = ({ bar, baz }: Props) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo); NOTE: This method will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.reactGlobal Pre-applies the isReact option to true, and isReactGlobal option to true. Shortcut for memoizing functional components in React across all instances. import moize from 'moize'; type Props = { bar: string, baz: string }; const Foo = ({ bar, baz }: Props) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactGlobal(Foo); NOTE: This method will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the isSerialized option to true. import moize from 'moize'; const foo = (bar: string, baz: string) =&gt; `${bar} ${baz}`; export default moize.serialize(foo); Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from 'moize'; type Props = { someProp: string }; const Foo = (props: Props) =&gt; &lt;div {...props} /&gt;; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 5 const LastFiveFoo = moize.maxSize(5)(MemoizedFoo); You can also create an options-first curriable version of moize if you only pass the options: import moize from 'moize'; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ isSerialized: true, maxSize: 5 }); const foo = bird =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo); You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from 'moize'; // creates a moizer that will have the options of // {isReact: true, maxAge: 5000, maxSize: 5} const superLimitedReactMoize = moize.compose( moize.react, moize.maxSize(5), moize.maxAge(5000), ); Collecting statistics As-of version 5.0.0, you can collect statistics of moize to determine if your cached methods are effective. import moize from 'moize'; moize.collectStats(); const fn = (foo, bar) =&gt; [foo, bar]; const moized = moize(fn); moized('foo', 'bar'); moized('foo', 'bar'); moized.getStats(); // {\"calls\": 2, \"hits\": 1, \"usage\": \"50%\"} NOTE: It is recommended not to activate this in production, as it will have a performance decrease. Introspection getStats Get the statistics for a specific function, or globally. collectStats(); const fn = (foo, bar) =&gt; [foo, bar]; const moized = moize(fn); const otherFn = bar =&gt; bar.slice(0, 1); const otherMoized = moize(otherFn, { profileName: 'otherMoized' }); moized('foo', 'bar'); moized('foo', 'bar'); moized.getStats(); // {\"calls\": 2, \"hits\": 1, \"usage\": \"50%\"} otherMoized(['baz']); moize.getStats('otherMoized'); // {\"calls\": 1, \"hits\": 0, \"usage\": \"0%\"} moize.getStats(); /* { \"calls\": 3, \"hits\": 1, \"profiles\": { \"fn at Object..src/utils.js (http://localhost:3000/app.js:153:68)\": { \"calls\": 2, \"hits\": 1, \"usage\": \"50%\" }, \"otherMoized\": { \"calls\": 1, \"hits\": 0, \"usage\": \"0%\" } }, \"usage\": \"33.3333%\" } */ isCollectingStats Are statistics being collected on memoization usage. moize.isCollectingStats(); // false collectStats(); moize.isCollectingStats(); // true isMoized Is the function passed a moized function. const fn = () =&gt; {}; const moizedFn = moize(fn); moize.isMoized(fn); // false moize.isMoized(moizedFn); // true Direct cache manipulation The cache is available on the moized function as a property, and while it is not recommended to modify it directly, that option is available for edge cases. cache The shape of the cache is as follows: type Cache = { keys: (any[])[]; // also available as Moize.Key[] size: number; values: any[]; // also available as Moize.Value[] }; Regardless of how the key is transformed, it is always stored as an array (if the value returned is not an array, it is coalesced to one). NOTE: The order of keys and values should always align, so be aware when manually manipulating the cache that you need to manually keep in sync any changes to those arrays. cache.snapshot The cache is mutated internally for performance reasons, so logging out the cache at a specific step in the workflow may not give you the information you need. As such, to help with debugging you can request the cacheSnapshot, which has the same shape as the cache but is a shallow clone of each property for persistence. There are also convenience methods provided on the moized function which allow for programmatic manipulation of the cache. clear () =&gt; boolean This will clear all values in the cache, resetting it to an empty state. const memoized = moize((item: any) =&gt; item); const didClear = memoized.clear(); This returns true if cache cleared successfully. delete (key: Moize.Key) =&gt; boolean This will remove the provided key from cache. key should be an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((item: any) =&gt; any); const foo = { bar: 'baz' }; memoized(foo); const didRemove = memoized.delete([foo]); // will re-execute, as it is no longer in cache memoized(foo); get (key: Moize.Key) =&gt; Moize.Value | void Returns the value in cache if the key matches, else returns undefined. key should be an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first: string, second: string) =&gt; [first, second]); memoized('foo', 'bar'); console.log(memoized.get(['foo', 'bar'])); // [\"foo\",\"bar\"] console.log(memoized.get(['bar', 'baz'])); // undefined getStats () =&gt; Moize.StatsObject Returns the statistics for the function. collectStats(); const memoized = moize((first: string, second: string) =&gt; [first, second]); memoized('foo', 'bar'); memoized('foo', 'bar'); console.log(memoized.getStats()); // {\"calls\": 2, \"hits\": 1, \"usage\": \"50%\"} NOTE: You must be collecting statistics for this to be populated. has (key: Moize.Key) =&gt; boolean This will return true if a cache entry exists for the key passed, else will return false. key should be an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first: string, second: string) =&gt; [first, second]); memoized('foo', 'bar'); console.log(memoized.has(['foo', 'bar'])); // true console.log(memoized.has(['bar', 'baz'])); // false keys () =&gt; Moized.Key[] This will return a list of the current keys in cache. const memoized = moize((item: any) =&gt; any); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // [['foo'], [{baz: 'baz'}]] The value returned is true if an entry was deleted, false if not. NOTE: This will only remove keys that exist in the cache, and will do nothing if the key does not exist. set (key: Moize.Key, value: Moize.Value) =&gt; boolean This will manually add the value at key in cache if key does not already exist, or update the value at key if it does. key should be an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize((item: string) =&gt; item); // adds the key =&gt; value, as it is not in cache memoized.set(['foo'], 'bar'); // pulls from cache memoized('foo'); // updates the key =&gt; value, as it already is in cache memoized.set(['foo'], 'baz'); The value returned is true if an entry was added / updated, false if not. values () =&gt; Moize.Value[] This will return a list of the current values in cache. const memoized = moize((item: any) =&gt; ({ item })); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}] Benchmarks All values provided are the number of operations per second calculated by benchee, where a higher value is better. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, using single and multiple parameters with different object types. The results were averaged to determine overall speed across possible usage. NOTE: lodash, ramda, and underscore do not support mulitple-parameter memoization without use of a resolver function. For consistency in comparison, each use the same resolver that returns the result of JSON.stringify on the arguments. Name Overall (average) single primitive single array single object multiple primitive multiple array multiple object moize 28,592,886 37,390,978 28,443,977 28,377,652 24,972,215 25,001,120 24,998,368 lru-memoize 21,491,988 39,937,384 20,342,667 20,924,765 17,346,234 16,322,914 17,300,359 lodash 12,104,503 25,416,048 23,301,328 27,505,049 1,389,241 1,087,838 877,620 memoizee 9,515,597 15,799,929 10,643,471 10,740,599 6,572,612 7,013,962 6,818,388 fast-memoize 7,463,418 51,566,160 1,615,649 1,426,880 1,268,116 979,444 819,221 memoizerific 5,117,778 5,641,768 5,539,880 5,533,768 4,496,953 4,711,212 4,705,524 underscore 4,230,089 20,965,582 2,108,270 1,828,023 1,459,836 1,126,566 910,574 mem 4,089,526 19,888,317 2,093,008 1,786,244 2,345,978 1,661,802 1,054,462 ramda 4,070,948 21,712,404 2,335,372 2,066,631 1,498,134 1,153,950 916,465 addy-osmani 2,200,040 5,824,585 1,586,101 1,448,906 3,081,196 975,378 775,256 Filesize moize is fairly small (about 3.2KB when minified and gzipped), however it provides a large number of configuration options to satisfy a number of edge cases. If filesize is a concern, you may consider using micro-memoize. This is the memoization library that powers moize under-the-hood, and will handle most common use cases at 1/2 the size of moize. Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 9+ Safari 6+ iOS 8+ Android 4+ Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: benchmark =&gt; run the benchmark suite pitting moize against other libraries in common use-cases benchmark:alternative =&gt; run the benchmark suite for alternative forms of caching in moize build =&gt; run rollup to build the distributed files in dist clean =&gt; run clean:lib, clean:es, clean:dist, and clean:docs clean:dist =&gt; run rimraf on the dist folder clean:docs =&gt; run rimraf on the docs folder clean:es =&gt; run rimraf on the es folder clean:lib =&gt; run rimraf on the lib folder dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs clean:dist and build docs =&gt; runs clean:docs and builds the docs via jsdoc flow =&gt; runs flow check on the files in src lint =&gt; runs ESLint against all files in the src folder lint:fix =&gt; runs `lint``, fixing any errors if possible postpublish =&gt; runs docs prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, flow, test:coverage, transpile:lib, transpile:es, and dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile:es =&gt; run babel against all files in src to create files in es, preserving ES2015 modules (for pkg.module) transpile:lib =&gt; run babel against all files in src to create files in lib Ã— Search results Close Documentation generated by JSDoc 3.6.2 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
